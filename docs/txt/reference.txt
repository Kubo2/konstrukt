Konstrukt Reference
===================

This document contains a description of the features of Konstrukt. For a more hands-on introduction, you should start out with [getting started](getting-started-part1.html).

There is also an autogenerated [api-reference](apidocs.html), which contains all classes, interfaces and methods in the library.

If you find any errors - even if it's just a spelling mistake, or a dodgy phrasing - don't hestitate to tell about it.

Troels Knak-Nielsen, January 2009, troelskn@gmail.com

component essentials
--------------------

A component is a class that extends from `k2_Component`. Its purpose is to handle a request or delegate control to anothe3r component, that can handle it. This is much similar to how the Apache web server is structured. The way a component is addressed is through the URL path. Each path segment is mapped to a component. The special thing about Konstrukt in this respect, is that the exact mapping is determined at runtime. Each component is fully tasked with choosen the next component in the chain. This is a very powerful concept, but can also be slightly hard to comprehend at first. As a newcomer you may therefore find the [dispatch logging](debugging) useful.

###dispatch life-cycle

A component is instantiated as an object before use. To allow for maximum flexibility in implementation, the constructor is not used for passing essential dependencies. These are instead passed immediately after creation through setters. Of these dependencies, the most important is the context, which will usually be another component instance.

A a developer you have great control over the creation of components. You can read more about this in the section on [component creation](#component-creation).

###dispatch, map, forward

Once the component is instantiated, it is given control by the context calling the `dispatch()` method. The purpose of this method is to inspect the url subspace and either determine that it is the final handler in the chain, or forward control to another component, which will go through the same process. These choices corresponds to the methods `forward()` and `execute()`. To make the choice, the method `map()` is used. As a developer, you will often override `map()` to implement url mapping logic.

###execute, GET, POST

The `execute()` method is the first method invoked for the handling component. It is unusual to override this in concrete components, although there are cases for it. Since execute is invoked for any kind of HTTP-method, it is a good place to load model components that are identified by the url of the component. The default implementation of `execute()` inspects the HTTP-method and delegates control to one of `GET()`, `POST()`, `HEAD()`, `PUT()` or `DELETE()`. In most web applications, you will probably just concern your self with the first two, since theese are the only one widely supported by browsers. Luckily they are also the most important.

###renderers


The `GET()` and `POST()` methods can be overridden, but it's now recommended that you don't override `GET()`. The default implementation of `GET()` will negotiate the content-type, and finally delegate control to a render method. So for most applications, you would implement `renderHtml()`. You can implement multiple renderers, and the negotiation will pick the best candidate. The naming of renderers corresponds to their content-type per the following chart:

content-type             | short name | render method
------------------------ | ---------- | -------------
text/html                |    html    | renderHtml
text/html+edit           |    edit    | renderEdit
text/xml                 |    xml     | renderXml
text/plain               |    text    | renderText
text/csv                 |    csv     | renderCsv
text/x-vcard             |    vcard   | renderVcard
application/atom+xml     |    atom    | renderAtom
application/calendar+xml |    xcal    | renderXCal
application/rdf+xml      |    rdf     | renderRdf
application/json         |    json    | renderJson
application/pdf          |    pdf     | renderPdf
image/svg+xml            |    svg     | renderSvg

If a component supports multiple renderers, you can refer to a specific representation by prefixing the url with a semicolon and the short-name. Eg. `/foo/bar;csv` is the CSV representation of `/foo/bar`. When specifying the content-type this way, the Accept header is disregarded.

The type `text/html+edit` is meant for a html form to edit the resource.

If you need a content-type that isn't listed above, you can add it to the `$renderers` property in your component. The format is:

..php
$this->renderers['test/html;html'] = 'renderHtml';

The return type of a renderer should either be a string (Which is expected to be a HTML fragment) or the method should throw a response. Remember to specify the content-type, if you're throwing a response to a non-HTML content-type.

http-input
----------

A component can access the various input that comes from a http-request. These are obtained through the `$context` object, rather than through a global place, which makes components very encasulated and -among other things - more testable.

Note that all these properties are accessed through methods, not as fields. So you would refer to `$this->name()` rather than `$this->name`

###name, subtype, subspace

Initially the most important input is probably the `name`. This returns the part of the url that this component belongs to. For the last component of the url `/foo/bar/cuux`, the name would be `cuux`. This property is often used as a primary key for identifying the underlying resource.

The `subtype` property is the part of a path-segment that comes after the name, delimited by a semi-colon. It's used internally to identify the content-type. As a developer you'll probably not need to access this very often.

The `subspace` property contains the remaining part of the path, for a component that isn't the last in the dispatch chain. For example, given the component identified as `bar` in the url `/foo/bar/cuux`, the subspace would be `cuux`. This property is also rarely used directly.

###query, body

In addition to the url/path, there are two important input sources; The query-string and the request body. In plain PHP, these are available through `$_GET` and `$_POST` respectively, but in Konstrukt they are accessed through `query()` and `body()`. This naming is moe precise, in that query-string parameters aren't just for GET requests, and a request body can come with other kinds of requests than a POST.

You can call the accessors without any arguments and get a hashmap back, or you can provide a name, and just get the value for that field. If the key isn't set, you will get back `null`, rather than a warning.

..php
  $this->query(); // array('foo' => 'bar')
  $this->query('foo'); // 'bar'

###querystring namespace

Because the querystring is shared amongst every component, you can sometimes run into problems when you need to pass parameters to multiple components (Not exactly a common requirement, but it can happen). Components can use a namespace to protect the querystring in these cases.
It's the context that specifies a namespace for its subcomponents, and it works completely transparent to the subcomponent. To create a component with a namespace, your `map()` method should return an array instead of a string, where the first element is the namespace and the second is the classname.

###sessions

Sessions are a very powerful feature for maintaining state in a web application. Unfortunately it's often overused. While there are cases where it's the best pick, you should generally try to use some other means of maintaining state, if at all possible. That said, Konstrukt provides access to PHPs session mechanism, through a wrapper.

Each component has a method `session()` that can be called in two ways. Either you provide an argument (Which should be a string), and you'll get the value of a session variable by that name back (or null, if it's not defined). Alternatively you can call it without any arguments, in which cas you'll the an object back of the type `k2_adapter_SessionAccess`. It has methods for getting/setting session variables and other session-related functions.

Note that you don't need to worry about calling `session_start()`, since this is done automatically by the wrapper.

###cookies

Cookies is a mixed client/server side way of maintaning state. Is has a number of limitations which makes it a less popular choice, but it can still be useful in certain cases. You can access cookies through a wrapper in Konstrukt.

The cookie wrapper works just as the session wrapper. Each component has a method `cookie()` that can be called with a parameter to retrieve the value of a cookie by that name, or without any arguments to get an object back of the type `k2_adapter_CookieAccess`.

###file uploads

In PHP files uploaded with a form are accessible through `$_FILLES`. Inside a component, you can access the same information through the method `file()`. You can either pass a parameter to get back a specific file or call it without any arguments to get a hashmap of all files. A file is wrapped in an object of the type `k2_adapter_UploadedFile`, which helps to abstract direct access to the filesystem away. As a side effect it also has a simpler interface than PHPs native handling of file uploads. To save an uploaded file, just call `writeTo($path_destination)` with the destination as argument.

Note that you need to go through the [regular hoops to get file uploads working](http://www.php.net/features.file-upload.post-method.php). Most importantly you need to set the `enctype="multipart/form-data"` property on your form tag.

url generation
--------------

All components are tightly coupled to a url. Components can parse (dispatch) urls, and they can also generate urls. To make your application as flexible as possible, it is recommended that you generate internal urls, using the `url()` method, rather than hardcoding them as strings. From within a component, you can call `url()` without any parameters to get a url pointing to the current component. As the first argument, you can pass a subspace, and as the second argument, you can pass a hash of query-string parameters. Eg.:

..php
   $this->url('foo', array('bar' => 42)); // -> /url/for/this/component/foo?bar=42

Generating urls this way, makes it easy to move components around without having to make any changes to the view.

Note that the first argument isn't automatically encoded. You can optionally pass an array of strings instead. These are then encoded and joined with a path-separator (A slash). Eg.:

..php
   $this->url(array('foo', 'cuux'), array('bar' => 42)); // -> /url/for/this/component/foo/cuux?bar=42

..note
  Apache has a [security feature](http://httpd.apache.org/docs/2.2/mod/core.html#allowencodedslashes) that disallows url path segments to contain an encoded slash. Thus, you should avoid names that contains slashes. In general, it is a good idea to stick to `a-z0-9_-` for url names.

###urlstate parameters

If a component needs to maintain view-related state, you have a limited set of options. In essence, the choice is between propagating state over urls (client side state) or using a server side mechanism (eg. sessions). Cookies are also a solution, but it has most of the problems associated with session state, and even some of its own. Client side state is often the superior choice, but it is tedious to do by hand. Konstrukt has therefore a mechanism build in to support this. Viewstate can be propagated as querystring parameters, using the `urlstate` property of a component. Properties that are set on the urlstate will be automatically set on any urls for the component, unless explicitly overridden. A typical usecase is for searches and other data-views.

Urlstate parameters is specified, along with their initial value, by implementing the `url_init` in your component. For example, to the following specifies a single parameter "foo". If no input is present for it, it has the value "bar":

..php
class MyStatefulComponent extends k2_component {
  protected $url_init = array('foo' => "bar");
}

If a urlstate paramater is passed on the querystring, it will automatically override the urlstate containers value. Eg. for a request with the query-string `?foo=cuux`, the following would yield "cuux":

..php
  $this->url_state->get('foo'); // -> "quux"

shared objects
--------------

A few objects are shared amongst all components.

###identity

The identity object is an object represeting the current user. Every component can access the identity by calling the access `identity()`. The default implementation is `k2_Anonymous`.

The identity is loaded from an `k2_DefaultIdentityLoader`, that can be configured with the bootstrap. An identity-loader is a simple factory, that gets passed the top-level context, and is expected to return an instance of `k2_Identity`. The usual use case is to load a user-object from the database or an authentication system.

###document

The document is an instance of `k2_Document`, and contains values that are global to the HTML document, such as title, css includes etc. A component can access the document via the `document()` method.

The default document has accessors for setting the title, adding external javascript and css files to `<head>`, and adding javascript code to run on page load. This is a fairly limited number of properties. If you need more, you could subclass `k2_Document` and set your own implementation in the bootstrap. It is recommended to keep such properties as specific as possible, to prevent that the object becomes a dumping ground for global variables.

abnormal responses
------------------

By default, components are expected to return a string of html, that can be a full or partial html document. This is the primary format of web applications, and therefore gets a special treatment over other formats. Sometimes though, you don't want the output to be embedded in the normal rendering mechanism or you need more finegrained control over the http response. This could be the case with alternative content-types, that shouldn't go in to the normal rendering chain, or it could be a redirect or an error code of some kind.

These are collectively called abnormal responses, because they circumvent the normal rendering chain. To do this, abnormal responses are implemented in Konstrukt as exceptions. To emit an abnormal response, you throw it instead of returning a string. The dispatcher will then catch it and use it for output.

There are two kinds of abnormal responses, for different levels of abstraction/control.

###httpresponse

A httpresponse is the most finegrained/least abstract kind of abnormal response. It gives you full control over the http-level output sent back to the client, including headers and status codes. You should use this for serving non-html content-types.

In addition to the generic `k2_Httpresponse`, there are three specialised variations that should be used for redirects:

`k2_MovedPermanently`
: Use this if the URL has changed (Eg. a page has been renamed).

`k2_SeeOther`
: Use this type of redirect specifically for redirecting after POST.

`k2_TemporaryRedirect`
: Use this type of redirect if the destination changes from request to request, or if you want the client to keep using the requested URI in the future.

###metaresponse

A metaresponse is a more abstract form of response. While you could just use a httpresponse, you should try to use these for, if possible, since it makes your application more flexible. A metaresponse is transformed into a concrete httpresponse by the dispatcher. The primary benefit of using a metaresponse over a httpresponse, is that it gives you control over rendering of various error-pages. For example, rather than constructing a httpresponse with status 404, you should use the metaresponse NotFound. This makes it possible to have a customised page for all "not found" responses.

The currently supported metaresponses are:

`k2_Forbidden`
: Raise this if the user doesn't have access to the requested resource.

`k2_PageNotFound`
: Raise this if the requested resource couldn't be found.

`k2_MethodNotAllowed`
: Raise this if resource doesn't support the requested HTTP method.

`k2_NotImplemented`
: This is roughly the HTTP equivalent to a "todo"

A metaresponse is associated with a componentname. For example, `k2_Forbidden` resolves to `k2_DefaultForbiddenComponent`. To get a customised handler for these types of responses, you can let your [component creator](#component-creation) return a custom component instead of the defaults.

templates
---------

Components usually return a html string. How they are rendered is largely left up to the developer. A common practise is to use a template engine though. Konstrukt includes a very simple template engine, which just wraps a regular php script in an output buffer. This strategy of using php as a template language works fine as long as you have some control over the provider of templates. It does have some drawbacks though, so some people might prefer to use a real template engine. Konstrukt comes with an example of how to use the Smarty template engine, but it should be equally simple to use any other template engine.

###php-templates

To use the default template engine, you should instantiate and object of `k2_Template`. The interface is simple; You pass a path to a php template. Calling `render()` will include the file inside a buffer and return the output. The calling component must pass a reference to itself to the template. This is to allow the template to access variables it might need. You should add methods on your component to provide the variables that your template might need.

The template binds a few global functions to make it easier for the template to call certain common features with a simple syntax. These are:

`e()`
: This function escapes htmlspecialcharacters in input and prints it in-place. Use this for embedding values in html-documents.
`__()`, `t()`
: These are both aliases for `$context->__()`. You can use this hook for implementing i18n support in your application. Note that there is no default implementation for `__`, so you need to explicitly implement this in your components, if you wish to support the feature.
`url()`
: This is bound to `$context->url()`.

component creation
------------------

In the [dispatch process](#dispatch-map-forward), a component may delegate control to a sub component. In doing so, the new component must be instantiated first. This task is handled by a discrete object, called a _component creator_. This can be configured in the bootstrap, which allows you to replace this without having to mingle with the internals of the library.

###di containers

The intended use for a component creator, is to allow the use of a [dependency injection container](http://c2.com/cgi/wiki?DependencyInjection) for creation of components. The base class for components (`k2_component`) doesn't have a constructor defined, which allows you free control over this for your components. This is practical because di containers often use the constructor to provide dependencies. By default, Konstrukt doesn't provide a di container, but it comes with bindings for [Phemto](https://phemto.svn.sourceforge.net/svnroot/phemto/trunk), and it's very simple to write adapters for other containers.

###createComponent

Most sub components are created from the dispatch process, but sometimes you need to create components manually. To do this, you can invoke the `createComponent()` method on a component, which would create a new sub component. The method takes an optional namespace, which is the [namespace used for querystring paramaters](#querystring-namespace).

encoding
--------

Until version 6 becomes current, PHP is stuck with a primitive view of string data, where strings are treated as bytestreams. Many libraries, extensions and even core functionality in PHP, assumes that strings are singlebyte streams. This means that each byte is interpreted as a character, the consequence being that only 256 different characters can be represented. Furthermore, the default charset assumed is ISO-8859-1 (also known as latin1). As long as we only want to represent western European texts this suffices, but in our multi cultural world, this is inadequate.

###how to use utf-8

Even if your main audience is English speaking, your users may still have foreign names, that can't be written with the limited charset of latin1. Currently, the best solution is therefore to use UTF-8 as encoding throughout your application. This strategy does have its pitfalls, but so does using latin1. It is important to get these things right from the beginning, since it's a thing that is very hard to change later.

Konstrukt defaults to speak UTF-8 at the HTTP-level. If you use a database, you should make sure that data is stored as UTF-8 or another Unicode capable encoding, and you should also make sure that the connection between PHP and database is set to UTF-8 (This only apply to some databases, such as MySql). Also, make sure that any files - especially template files - are saved as UTF-8 (Without BOM). This covers the most common problems with UTF-8.

There is a good overview of the core PHP functions, that needs special treatment to work with UTF-8 at [http://www.phpwact.org/php/i18n/utf-8](http://www.phpwact.org/php/i18n/utf-8).

###plan b (legacy applications)

environment (configuration?)
----------------------------

###file layout (starterpack)

###static content

and using Konstrukt in a context, href_base

###global handlers

errorhandler etc.

###bootstrap

the bootstrap class

debugging
---------

###debug bar

(dispatch logging, var-dump-2.0)

###logs

###functional testing

